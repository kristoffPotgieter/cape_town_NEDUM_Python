<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>calibration.calib_main_func &mdash; NEDUM-2D for CoCT  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> NEDUM-2D for CoCT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme_link.html">Introducing NEDUM-2D</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license_rst.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../main_nb.html">Notebook: run model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../calib_nb.html">Notebook: run calibration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guidelines.html">User guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../use_case.html">Use case</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../technical_doc.html">Technical documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input_tables.html">Input tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../data_bases.html">Data bases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../data_sets.html">Data sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../math_appendix.html">Math appendix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_ref.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install_help.html">Installation help</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">NEDUM-2D for CoCT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>calibration.calib_main_func</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for calibration.calib_main_func</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.matlib</span>
<span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">calibration.sub.compute_income</span> <span class="k">as</span> <span class="nn">calcmp</span>
<span class="kn">import</span> <span class="nn">calibration.sub.import_employment_data</span> <span class="k">as</span> <span class="nn">calemp</span>
<span class="kn">import</span> <span class="nn">calibration.sub.estimate_parameters_by_scanning</span> <span class="k">as</span> <span class="nn">calscan</span>
<span class="kn">import</span> <span class="nn">calibration.sub.estimate_parameters_by_optimization</span> <span class="k">as</span> <span class="nn">calopt</span>
<span class="kn">import</span> <span class="nn">calibration.sub.import_amenities</span> <span class="k">as</span> <span class="nn">calam</span>


<div class="viewcode-block" id="estim_construct_func_param"><a class="viewcode-back" href="../../api_ref.html#calibration.calib_main_func.estim_construct_func_param">[docs]</a><span class="k">def</span> <span class="nf">estim_construct_func_param</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">data_sp</span><span class="p">,</span>
                               <span class="n">threshold_income_distribution</span><span class="p">,</span>
                               <span class="n">income_distribution</span><span class="p">,</span> <span class="n">data_rdp</span><span class="p">,</span> <span class="n">housing_types_sp</span><span class="p">,</span>
                               <span class="n">data_number_formal</span><span class="p">,</span> <span class="n">data_income_group</span><span class="p">,</span>
                               <span class="n">selected_density</span><span class="p">,</span>
                               <span class="n">path_data</span><span class="p">,</span> <span class="n">path_precalc_inp</span><span class="p">,</span> <span class="n">path_folder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate coefficients of housing production function (Cobb-Douglas).</span>

<span class="sd">    This function leverages a partial relation from our general equilibrium</span>
<span class="sd">    model, that is estimated on SP data which does not enter the simulations</span>
<span class="sd">    as an input. More precisely, it combines the expression of the optimal</span>
<span class="sd">    housing supply in the formal private sector with the highest bid condition</span>
<span class="sd">    (see technical documentation for math formulas).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    options : dict</span>
<span class="sd">        Dictionary of default options</span>
<span class="sd">    param : dict</span>
<span class="sd">        Dictionary of default parameters</span>
<span class="sd">    data_sp : DataFrame</span>
<span class="sd">        Table yielding, for each Small Place (1,046), the average dwelling size</span>
<span class="sd">        (in m²), the average land price and annual income level (in rands),</span>
<span class="sd">        the size of unconstrained area for construction (in m²), the total area</span>
<span class="sd">        (in km²), the distance to the city centre (in km), whether or not the</span>
<span class="sd">        location belongs to Mitchells Plain, and the SP code</span>
<span class="sd">    threshold_income_distribution : ndarray(int32)</span>
<span class="sd">        Annual income level (in rands) above which a household is taken as</span>
<span class="sd">        being part of one of the 4 income groups in the model</span>
<span class="sd">    income_distribution : ndarray(uint16, ndim=2)</span>
<span class="sd">        Exogenous number of households in each Small Place (1,046) for each</span>
<span class="sd">        income group in the model (4)</span>
<span class="sd">    data_rdp : DataFrame</span>
<span class="sd">        Table yielding, for each grid cell (24,014), the associated cumulative</span>
<span class="sd">        count of cells with some formal subsidized housing, and the associated</span>
<span class="sd">        area (in m²) dedicated to such housing</span>
<span class="sd">    housing_types_sp : DataFrame</span>
<span class="sd">        Table yielding, for each Small Place (1,046), the number of informal</span>
<span class="sd">        backyards, of informal settlements, and total dwelling units, as well</span>
<span class="sd">        as their (centroid) x and y coordinates</span>
<span class="sd">    data_number_formal : Series</span>
<span class="sd">        Number of formal private housing units considered for each Small Place</span>
<span class="sd">        (1,046)</span>
<span class="sd">    data_income_group : ndarray(float64)</span>
<span class="sd">        Categorical variable indicating, for each Small Place (1,046), the</span>
<span class="sd">        dominant income group (from 0 to 3)</span>
<span class="sd">    selected_density : Series</span>
<span class="sd">        Dummy variable allowing for sample selection across Small Places</span>
<span class="sd">        (1,046) for regressions that are only valid in the formal private</span>
<span class="sd">        housing sector</span>
<span class="sd">    path_data : str</span>
<span class="sd">        Path towards data used in the model</span>
<span class="sd">    path_precalc_inp : str</span>
<span class="sd">        Path for precalcuted input data (calibrated parameters)</span>
<span class="sd">    path_folder : str</span>
<span class="sd">        Path towards the root data folder</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coeff_b : float64</span>
<span class="sd">        Calibrated capital elasticity in housing production function</span>
<span class="sd">    coeff_a : float64</span>
<span class="sd">        Calibrated land elasticity in housing production function</span>
<span class="sd">    coeffKappa : float64</span>
<span class="sd">        Calibrated scale factor in housing production function</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We define our outcome variable</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">data_number_formal</span><span class="p">[</span><span class="n">selected_density</span><span class="p">])</span>
    <span class="c1"># We define our independent variables</span>
    <span class="c1"># Note that we use data_sp[&quot;unconstrained_area&quot;] (which is accurate data at</span>
    <span class="c1"># SP level) rather than coeff_land (which is an estimate at grid level)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_sp</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">][</span><span class="n">selected_density</span><span class="p">])),</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">data_sp</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">][</span><span class="n">selected_density</span><span class="p">]),</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">data_sp</span><span class="p">[</span><span class="s2">&quot;dwelling_size&quot;</span><span class="p">][</span><span class="n">selected_density</span><span class="p">]),</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;max_land_use&quot;</span><span class="p">]</span>
                         <span class="o">*</span> <span class="n">data_sp</span><span class="p">[</span><span class="s2">&quot;unconstrained_area&quot;</span><span class="p">][</span><span class="n">selected_density</span><span class="p">])])</span>
        <span class="p">)</span>
    <span class="c1"># NB: Our data set for dwelling sizes only provides the average dwelling</span>
    <span class="c1"># size at the Sub-Place level, aggregating formal and informal housing</span>

    <span class="c1"># We run the linear regression</span>
    <span class="n">modelSpecification</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;drop&#39;</span><span class="p">)</span>
    <span class="n">model_construction</span> <span class="o">=</span> <span class="n">modelSpecification</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">model_construction</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
    <span class="n">parametersConstruction</span> <span class="o">=</span> <span class="n">model_construction</span><span class="o">.</span><span class="n">params</span>

    <span class="c1"># We export outputs of the model</span>
    <span class="n">coeff_b</span> <span class="o">=</span> <span class="n">parametersConstruction</span><span class="p">[</span><span class="s2">&quot;x1&quot;</span><span class="p">]</span>
    <span class="n">coeff_a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">coeff_b</span>
    <span class="c1"># Scale factor formula comes from zero profit condition combined with</span>
    <span class="c1"># footnote 16 from Pfeiffer et al. (typo in original paper)</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;correct_kappa&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">coeffKappa</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">coeff_b</span> <span class="o">/</span> <span class="n">coeff_a</span><span class="p">)</span> <span class="o">**</span> <span class="n">coeff_b</span><span class="p">)</span>
                      <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">parametersConstruction</span><span class="p">[</span><span class="s2">&quot;const&quot;</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;correct_kappa&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">coeffKappa</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">coeff_b</span><span class="p">)</span> <span class="o">**</span> <span class="n">coeff_b</span><span class="p">)</span>
                      <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">parametersConstruction</span><span class="p">[</span><span class="s2">&quot;const&quot;</span><span class="p">]))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">path_precalc_inp</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>

    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path_precalc_inp</span> <span class="o">+</span> <span class="s1">&#39;calibratedHousing_b.npy&#39;</span><span class="p">,</span> <span class="n">coeff_b</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path_precalc_inp</span> <span class="o">+</span> <span class="s1">&#39;calibratedHousing_kappa.npy&#39;</span><span class="p">,</span> <span class="n">coeffKappa</span><span class="p">)</span>

    <span class="c1"># We add the option in case we want to reverse estimated elasticties to</span>
    <span class="c1"># stick closer to the literature (this is just a test)</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;reverse_elasticities&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">coeff_a</span> <span class="o">=</span> <span class="n">coeff_b</span>
        <span class="n">coeff_b</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">coeff_a</span>
        <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;correct_kappa&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coeffKappa</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">coeff_b</span> <span class="o">/</span> <span class="n">coeff_a</span><span class="p">)</span> <span class="o">**</span> <span class="n">coeff_b</span><span class="p">)</span>
                          <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">model_construction</span><span class="o">.</span><span class="n">intercept_</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;correct_kappa&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">coeffKappa</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">coeff_b</span><span class="p">)</span> <span class="o">**</span> <span class="n">coeff_b</span><span class="p">)</span>
                          <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">model_construction</span><span class="o">.</span><span class="n">intercept_</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">coeff_b</span><span class="p">,</span> <span class="n">coeff_a</span><span class="p">,</span> <span class="n">coeffKappa</span></div>


<div class="viewcode-block" id="estim_incomes_and_gravity"><a class="viewcode-back" href="../../api_ref.html#calibration.calib_main_func.estim_incomes_and_gravity">[docs]</a><span class="k">def</span> <span class="nf">estim_incomes_and_gravity</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">list_lambda</span><span class="p">,</span>
                              <span class="n">households_per_income_class</span><span class="p">,</span>
                              <span class="n">average_income</span><span class="p">,</span> <span class="n">income_distribution</span><span class="p">,</span>
                              <span class="n">spline_inflation</span><span class="p">,</span> <span class="n">spline_fuel</span><span class="p">,</span>
                              <span class="n">spline_population_income_distribution</span><span class="p">,</span>
                              <span class="n">spline_income_distribution</span><span class="p">,</span>
                              <span class="n">path_data</span><span class="p">,</span> <span class="n">path_precalc_inp</span><span class="p">,</span>
                              <span class="n">path_precalc_transp</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate incomes per job center and income group, with gravity parameter.</span>

<span class="sd">    This function leverages theoretical formulas from</span>
<span class="sd">    calibration.sub.compute_income and data imported through the</span>
<span class="sd">    calibration.sub.import_employment_data module. It first import transport</span>
<span class="sd">    costs and observed number of commuters per selected job centre and income</span>
<span class="sd">    group, then estimates the associated incomes for a given gravity parameter</span>
<span class="sd">    by minimizing the error over the simulated number of commuters. Then, it</span>
<span class="sd">    selects among a list of scanned values the final value of the gravity</span>
<span class="sd">    parameter (and the associated incomes) by minimizing the error over the</span>
<span class="sd">    distribution of commuters along their residence-workplace distances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    param : dict</span>
<span class="sd">        Dictionary of default parameters</span>
<span class="sd">    grid : DataFrame</span>
<span class="sd">        Table yielding, for each grid cell (24,014), its x and y</span>
<span class="sd">        (centroid) coordinates, and its distance (in km) to the city centre</span>
<span class="sd">    list_lambda : ndarray(float64)</span>
<span class="sd">        List of values over which to scan for the gravity parameter used in</span>
<span class="sd">        the commuting choice model</span>
<span class="sd">    households_per_income_class : ndarray(float64)</span>
<span class="sd">        Exogenous total number of households per income group (excluding people</span>
<span class="sd">        out of employment, for 4 groups)</span>
<span class="sd">    average_income : ndarray(float64)</span>
<span class="sd">        Average median income for each income group in the model (4)</span>
<span class="sd">    income_distribution : ndarray(uint16, ndim=2)</span>
<span class="sd">        Exogenous number of households in each Small Place (1,046) for each</span>
<span class="sd">        income group in the model (4)</span>
<span class="sd">    spline_inflation : interp1d</span>
<span class="sd">        Linear interpolation for inflation rate (in base 100 relative to</span>
<span class="sd">        baseline year) over the years (baseline year set at 0)</span>
<span class="sd">    spline_fuel : interp1d</span>
<span class="sd">        Linear interpolation for fuel price (in rands per km)</span>
<span class="sd">        over the years (baseline year set at 0)</span>
<span class="sd">    spline_population_income_distribution : interp1d</span>
<span class="sd">        Linear interpolation for total population per income group in the data</span>
<span class="sd">        (12) over the years (baseline year set at 0)</span>
<span class="sd">    spline_income_distribution : interp1d</span>
<span class="sd">        Linear interpolation for median annual income (in rands) per income</span>
<span class="sd">        group in the data (12) over the years (baseline year set at 0)</span>
<span class="sd">    path_data : str</span>
<span class="sd">        Path towards data used in the model</span>
<span class="sd">    path_precalc_inp : str</span>
<span class="sd">        Path for precalcuted input data (calibrated parameters)</span>
<span class="sd">    path_precalc_transp : str</span>
<span class="sd">        Path for precalcuted transport inputs (intermediate outputs from</span>
<span class="sd">        commuting choice model)</span>
<span class="sd">    options : dict</span>
<span class="sd">        Dictionary of default options</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    incomeCentersKeep : ndarray(float64, ndim=2)</span>
<span class="sd">        Calibrated average annual household income (including unemployment)</span>
<span class="sd">        for each income group (4), per grid cell (24,014)</span>
<span class="sd">    lambdaKeep : float64</span>
<span class="sd">        Calibrated gravity parameter from the commuting choice model</span>
<span class="sd">    cal_avg_income : ndarray(float64)</span>
<span class="sd">        Overall calibrated average income across income groups (4), for</span>
<span class="sd">        validation only</span>
<span class="sd">    scoreKeep : ndarray(float64)</span>
<span class="sd">        Mean ratio of simulated over observed number of commuters per job</span>
<span class="sd">        center (185), collapsed at the income-group level (4): captures the</span>
<span class="sd">        error over our calibrated parameters</span>
<span class="sd">    bhattacharyyaDistances : ndarray(float64)</span>
<span class="sd">        Bhattacharyya distances (measure the similarity of two probability</span>
<span class="sd">        distributions) between the calculated distribution of commuting</span>
<span class="sd">        distances and aggregates from the Transport Survey, for each scanned</span>
<span class="sd">        value of the gravity parameter. This is used as an auxiliary measure</span>
<span class="sd">        to pin down a unique gravity parameter (and associated matrix of</span>
<span class="sd">        incomes), and is only given as an output of the function for reference.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We import number of workers in each selected job center.</span>
    <span class="c1"># Note that it is rescaled to match aggregate income distribution in census</span>
    <span class="n">job_centers</span> <span class="o">=</span> <span class="n">calemp</span><span class="o">.</span><span class="n">import_employment_data</span><span class="p">(</span>
        <span class="n">households_per_income_class</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">path_data</span><span class="p">)</span>

    <span class="c1"># We import transport cost data.</span>
    <span class="c1"># Note that we reason at the SP level here. Also note that we are</span>
    <span class="c1"># considering round trips and households made up of two people.</span>
    <span class="p">(</span><span class="n">timeOutput</span><span class="p">,</span> <span class="n">distanceOutput</span><span class="p">,</span> <span class="n">monetaryCost</span><span class="p">,</span> <span class="n">costTime</span>
     <span class="p">)</span> <span class="o">=</span> <span class="n">calcmp</span><span class="o">.</span><span class="n">import_transport_costs</span><span class="p">(</span>
         <span class="n">grid</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">households_per_income_class</span><span class="p">,</span>
         <span class="n">spline_inflation</span><span class="p">,</span> <span class="n">spline_fuel</span><span class="p">,</span> <span class="n">spline_population_income_distribution</span><span class="p">,</span>
         <span class="n">spline_income_distribution</span><span class="p">,</span>
         <span class="n">path_precalc_inp</span><span class="p">,</span> <span class="n">path_precalc_transp</span><span class="p">,</span> <span class="s1">&#39;SP&#39;</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

    <span class="c1"># Note that this is long to run.</span>
    <span class="c1"># Here again, we are considering rescaled income data.</span>
    <span class="p">(</span><span class="n">incomeCenters</span><span class="p">,</span> <span class="n">distanceDistribution</span><span class="p">,</span> <span class="n">scoreMatrix</span>
     <span class="p">)</span> <span class="o">=</span> <span class="n">calcmp</span><span class="o">.</span><span class="n">EstimateIncome</span><span class="p">(</span>
        <span class="n">param</span><span class="p">,</span> <span class="n">timeOutput</span><span class="p">,</span> <span class="n">distanceOutput</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">monetaryCost</span><span class="p">,</span> <span class="n">costTime</span><span class="p">,</span>
        <span class="n">job_centers</span><span class="p">,</span> <span class="n">average_income</span><span class="p">,</span> <span class="n">income_distribution</span><span class="p">,</span> <span class="n">list_lambda</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

    <span class="c1"># Gives aggregate statistics for % of commuters per distance bracket</span>
    <span class="c1"># NB: bracketsDistance = np.array([0, 5, 10, 15, 20, 25, 30, 35, 40, 200])</span>
    <span class="c1"># with floor residence-workplace distances in km</span>
    <span class="c1"># (see calibration.sub.compute_income)</span>
    <span class="c1"># TODO: need to include a data reference</span>
    <span class="n">data_distance_distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="mf">45.6174222</span><span class="p">,</span> <span class="mf">18.9010734</span><span class="p">,</span> <span class="mf">14.9972971</span><span class="p">,</span> <span class="mf">9.6725616</span><span class="p">,</span> <span class="mf">5.9425438</span><span class="p">,</span> <span class="mf">2.5368754</span><span class="p">,</span>
         <span class="mf">0.9267125</span><span class="p">,</span> <span class="mf">0.3591011</span><span class="p">,</span> <span class="mf">1.0464129</span><span class="p">])</span>

    <span class="c1"># Compute accessibility index</span>
    <span class="c1"># NB1: Bhattacharyya distance measures the similarity of two probability</span>
    <span class="c1"># distributions (here, data vs. simulated % of commuters)</span>
    <span class="c1"># NB2: Mahalanobis distance is a particular case of the Bhattacharyya</span>
    <span class="c1"># distance when the standard deviations of the two classes are the same</span>
    <span class="n">bhattacharyyaDistances</span> <span class="o">=</span> <span class="p">(</span>
        <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">data_distance_distribution</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                                   <span class="o">/</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">distanceDistribution</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="n">whichLambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">bhattacharyyaDistances</span><span class="p">)</span>

    <span class="c1"># Hence, we keep the lambda that minimizes the distance and the associated</span>
    <span class="c1"># income vector</span>
    <span class="n">lambdaKeep</span> <span class="o">=</span> <span class="n">list_lambda</span><span class="p">[</span><span class="n">whichLambda</span><span class="p">]</span>
    <span class="n">incomeCentersKeep</span> <span class="o">=</span> <span class="n">incomeCenters</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">whichLambda</span><span class="p">]</span>

    <span class="c1"># We also keep the associated error metric</span>
    <span class="n">scoreKeep</span> <span class="o">=</span> <span class="n">scoreMatrix</span><span class="p">[</span><span class="n">whichLambda</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Note that income is set to -inf for job centers and income groups in</span>
    <span class="c1"># which it could not be calibrated</span>

    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path_precalc_inp</span> <span class="o">+</span> <span class="s1">&#39;incomeCentersKeep.npy&#39;</span><span class="p">,</span> <span class="n">incomeCentersKeep</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path_precalc_inp</span> <span class="o">+</span> <span class="s1">&#39;lambdaKeep.npy&#39;</span><span class="p">,</span> <span class="n">lambdaKeep</span><span class="p">)</span>

    <span class="c1"># Note that it is unclear whether &quot;average&quot; income from data includes</span>
    <span class="c1"># unemployment or not: a priori, it does for short spells (less than one</span>
    <span class="c1"># year) and should therefore be slightly bigger than calibrated income</span>
    <span class="c1"># (which should reflect all unemployment): this is what we observe in</span>
    <span class="c1"># practice</span>
    <span class="n">incomeCentersKeep</span><span class="p">[</span><span class="n">incomeCentersKeep</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">cal_avg_income</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">incomeCentersKeep</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">incomeCentersKeep</span><span class="p">,</span> <span class="n">lambdaKeep</span><span class="p">,</span> <span class="n">cal_avg_income</span><span class="p">,</span> <span class="n">scoreKeep</span><span class="p">,</span>
            <span class="n">bhattacharyyaDistances</span><span class="p">)</span></div>


<div class="viewcode-block" id="estim_util_func_param"><a class="viewcode-back" href="../../api_ref.html#calibration.calib_main_func.estim_util_func_param">[docs]</a><span class="k">def</span> <span class="nf">estim_util_func_param</span><span class="p">(</span><span class="n">data_number_formal</span><span class="p">,</span> <span class="n">data_income_group</span><span class="p">,</span>
                          <span class="n">housing_types_sp</span><span class="p">,</span> <span class="n">data_sp</span><span class="p">,</span>
                          <span class="n">coeff_a</span><span class="p">,</span> <span class="n">coeff_b</span><span class="p">,</span> <span class="n">coeffKappa</span><span class="p">,</span> <span class="n">interest_rate</span><span class="p">,</span>
                          <span class="n">incomeNetOfCommuting</span><span class="p">,</span> <span class="n">selected_density</span><span class="p">,</span>
                          <span class="n">path_data</span><span class="p">,</span> <span class="n">path_precalc_inp</span><span class="p">,</span>
                          <span class="n">options</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calibrate utility function parameters.</span>

<span class="sd">    This function leverages the following modules: import_amenities,</span>
<span class="sd">    estimate_parameters_by_scanning, and estimate_parameters_by_optimization.</span>
<span class="sd">    As before, we use partial relations coming from our general equilibrium</span>
<span class="sd">    structure (see technical documentation for math formulas). This time, we</span>
<span class="sd">    look at the utility function parameters that maximize a composite</span>
<span class="sd">    likelihood function for the fit on observed amenities, dwelling sizes, and</span>
<span class="sd">    population sorting by income (see calibration.sub.loglikelihood module).</span>
<span class="sd">    We proceed first by scanning over a discrete range of parameter values,</span>
<span class="sd">    then by running a smooth solver taking outputs from scanning as initial</span>
<span class="sd">    values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_number_formal : Series</span>
<span class="sd">        Number of formal private housing units considered for each Small Place</span>
<span class="sd">        (1,046)</span>
<span class="sd">    data_income_group : ndarray(float64)</span>
<span class="sd">        Categorical variable indicating, for each Small Place (1,046), the</span>
<span class="sd">        dominant income group (from 0 to 3)</span>
<span class="sd">    housing_types_sp : DataFrame</span>
<span class="sd">        Table yielding, for each Small Place (1,046), the number of informal</span>
<span class="sd">        backyards, of informal settlements, and total dwelling units, as well</span>
<span class="sd">        as their (centroid) x and y coordinates</span>
<span class="sd">    data_sp : DataFrame</span>
<span class="sd">        Table yielding, for each Small Place (1,046), the average dwelling size</span>
<span class="sd">        (in m²), the average land price and annual income level (in rands),</span>
<span class="sd">        the size of unconstrained area for construction (in m²), the total area</span>
<span class="sd">        (in km²), the distance to the city centre (in km), whether or not the</span>
<span class="sd">        location belongs to Mitchells Plain, and the SP code</span>
<span class="sd">    coeff_a : float64</span>
<span class="sd">        Calibrated land elasticity in housing production function</span>
<span class="sd">    coeff_b : float64</span>
<span class="sd">        Calibrated capital elasticity in housing production function</span>
<span class="sd">    coeffKappa : float64</span>
<span class="sd">        Calibrated scale factor in housing production function</span>
<span class="sd">    interest_rate : float64</span>
<span class="sd">        Interest rate for the overall economy, corresponding to an average</span>
<span class="sd">        over past years</span>
<span class="sd">    incomeNetOfCommuting : ndarray(float64, ndim=2)</span>
<span class="sd">        Expected annual income net of commuting costs (in rands, for</span>
<span class="sd">        one household), for each geographic unit, by income group (4)</span>
<span class="sd">    selected_density : Series</span>
<span class="sd">        Dummy variable allowing for sample selection across Small Places</span>
<span class="sd">        (1,046) for regressions that are only valid in the formal private</span>
<span class="sd">        housing sector</span>
<span class="sd">    path_data : str</span>
<span class="sd">        Path towards data used in the model</span>
<span class="sd">    path_precalc_inp : str</span>
<span class="sd">        Path for precalcuted input data (calibrated parameters)</span>
<span class="sd">    options : dict</span>
<span class="sd">        Dictionary of default options</span>
<span class="sd">    param : dict</span>
<span class="sd">        Dictionary of default parameters</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    calibratedUtility_beta : float64</span>
<span class="sd">        Calibrated surplus housing elasticity in households&#39; utility function</span>
<span class="sd">    calibratedUtility_q0 : float64</span>
<span class="sd">        Parametric basic need in housing (in m²). Note that this parameter is</span>
<span class="sd">        not an output of the calibration per se, as it is exogenously set. It</span>
<span class="sd">        is included here for reference as it enters the households&#39; utility</span>
<span class="sd">        function and enters the optimization programme as an input. Note that</span>
<span class="sd">        this could be optimized over (as in Pfeiffer et al.), but only within</span>
<span class="sd">        a narrow range of values to preserve feasibilty of allocations.</span>
<span class="sd">    cal_amenities : ndarray(float64)</span>
<span class="sd">        Calibrated amenity index for each grid cell (24,014): this is not</span>
<span class="sd">        normalized yet.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We select in which areas we actually measure the likelihood</span>
    <span class="c1"># NB: Again, there is a trade-off between empirical validity and</span>
    <span class="c1"># statistical power, which is why we use a less stringent sample selection</span>
    <span class="c1"># than for the calibration of construction function parameters</span>
    <span class="n">selectedSP</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">data_number_formal</span> <span class="o">&gt;</span> <span class="mf">0.90</span> <span class="o">*</span> <span class="n">housing_types_sp</span><span class="o">.</span><span class="n">total_dwellings_SP_2011</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">data_income_group</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># We are going to scan over values on which to optimize</span>

    <span class="c1"># For beta, we take a relatively wide acceptable range, as there is no</span>
    <span class="c1"># empirical counterpart (final value essentially depend on internal</span>
    <span class="c1"># validity) on which to base a priori knowledge, and it is the key</span>
    <span class="c1"># parameter over which we want to optimize</span>
    <span class="n">listBeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.23</span><span class="p">,</span> <span class="mf">0.331</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>

    <span class="c1"># For basic need in housing, we pin the value to the one estimated in</span>
    <span class="c1"># Pfeiffer et al. Again, we could optimize over this value, but this would</span>
    <span class="c1"># add a lot of numerical complexity, and we should not do it over a wide</span>
    <span class="c1"># range of values to stay within feasible allocations. Besides, this</span>
    <span class="c1"># parameter can be calibrated empirically (as is usually done in the</span>
    <span class="c1"># literature), which makes more sense than relying on an optimization</span>
    <span class="c1"># process made noisier by the number of parameters.</span>
    <span class="n">listBasicQ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;q0&quot;</span><span class="p">]])</span>

    <span class="c1"># Coefficient for spatial autocorrelation (not used)</span>
    <span class="n">listRho</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Utilities for simulations: we take levels close to what we expect</span>
    <span class="c1"># in equilibrium</span>
    <span class="n">utilityTarget</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="mi">15000</span><span class="p">,</span> <span class="mi">70000</span><span class="p">])</span>

    <span class="c1"># Then, we only allow utilities for the two richest income groups to vary,</span>
    <span class="c1"># for the sake of numerical simplicity and as they will drive most of the</span>
    <span class="c1"># changes in absolute values. Actually, we even exclude the poorest income</span>
    <span class="c1"># group from the analysis, again for the sake of numerical simplicity and</span>
    <span class="c1"># as it will in practice be crowded out of the formal private sector</span>
    <span class="c1"># (which drives most of our identification).</span>

    <span class="c1"># NB: Again, we restrict ourselves to a quite narrow range as we have some</span>
    <span class="c1"># a priori knowledge about welfare and we want to remain within feasible</span>
    <span class="c1"># allocations (which would not be the case with richer income groups</span>
    <span class="c1"># having a lower utility than poorer income groups, for instance)</span>

    <span class="n">listVariation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.96</span><span class="p">,</span> <span class="mf">1.041</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">)</span>
    <span class="n">initUti2</span> <span class="o">=</span> <span class="n">utilityTarget</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">listUti3</span> <span class="o">=</span> <span class="n">utilityTarget</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">listVariation</span>
    <span class="n">listUti4</span> <span class="o">=</span> <span class="n">utilityTarget</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">listVariation</span>

    <span class="c1"># We define our equation on formal rents: see technical documentation</span>
    <span class="c1"># for math formulas</span>
    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;correct_kappa&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;deprec_land&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dataRent</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">data_sp</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="n">coeff_a</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;depreciation_rate&quot;</span><span class="p">]</span>
               <span class="o">+</span> <span class="n">interest_rate</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">coeffKappa</span> <span class="o">*</span> <span class="n">coeff_b</span> <span class="o">**</span> <span class="n">coeff_b</span> <span class="o">*</span> <span class="n">coeff_a</span> <span class="o">**</span> <span class="n">coeff_a</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;correct_kappa&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;deprec_land&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dataRent</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">interest_rate</span> <span class="o">*</span> <span class="n">data_sp</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">])</span> <span class="o">**</span> <span class="n">coeff_a</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;depreciation_rate&quot;</span><span class="p">]</span>
               <span class="o">+</span> <span class="n">interest_rate</span><span class="p">)</span> <span class="o">**</span> <span class="n">coeff_b</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">coeffKappa</span> <span class="o">*</span> <span class="n">coeff_b</span> <span class="o">**</span> <span class="n">coeff_b</span> <span class="o">*</span> <span class="n">coeff_a</span> <span class="o">**</span> <span class="n">coeff_a</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;correct_kappa&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;deprec_land&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dataRent</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">data_sp</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="n">coeff_a</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;depreciation_rate&quot;</span><span class="p">]</span>
               <span class="o">+</span> <span class="n">interest_rate</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">coeffKappa</span> <span class="o">*</span> <span class="n">coeff_b</span> <span class="o">**</span> <span class="n">coeff_b</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;correct_kappa&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;deprec_land&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dataRent</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">data_sp</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">interest_rate</span><span class="p">)</span> <span class="o">**</span> <span class="n">coeff_a</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;depreciation_rate&quot;</span><span class="p">]</span>
               <span class="o">+</span> <span class="n">interest_rate</span><span class="p">)</span> <span class="o">**</span> <span class="n">coeff_b</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">coeffKappa</span> <span class="o">*</span> <span class="n">coeff_b</span> <span class="o">**</span> <span class="n">coeff_b</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="c1"># We get the built density in associated constructible land (per km²)</span>
    <span class="n">data_density</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">data_number_formal</span>
        <span class="o">/</span> <span class="p">(</span><span class="n">data_sp</span><span class="p">[</span><span class="s2">&quot;unconstrained_area&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">param</span><span class="p">[</span><span class="s2">&quot;max_land_use&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># We import amenity data at the SP level</span>
    <span class="n">amenities_sp</span> <span class="o">=</span> <span class="n">calam</span><span class="o">.</span><span class="n">import_amenities</span><span class="p">(</span><span class="n">path_data</span><span class="p">,</span> <span class="n">path_precalc_inp</span><span class="p">,</span> <span class="s1">&#39;SP&#39;</span><span class="p">)</span>
    <span class="c1"># We select amenity variables to be used in regressions</span>
    <span class="c1"># NB: choice has to do with relevance and exogeneity of variables</span>
    <span class="n">variables_regression</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;distance_ocean&#39;</span><span class="p">,</span> <span class="s1">&#39;distance_ocean_2_4&#39;</span><span class="p">,</span> <span class="s1">&#39;slope_1_5&#39;</span><span class="p">,</span> <span class="s1">&#39;slope_5&#39;</span><span class="p">,</span>
        <span class="s1">&#39;airport_cone2&#39;</span><span class="p">,</span> <span class="s1">&#39;distance_distr_parks&#39;</span><span class="p">,</span> <span class="s1">&#39;distance_biosphere_reserve&#39;</span><span class="p">,</span>
        <span class="s1">&#39;distance_train&#39;</span><span class="p">,</span> <span class="s1">&#39;distance_urban_herit&#39;</span><span class="p">]</span>

    <span class="c1"># We run the parameter scanning.</span>
    <span class="c1"># Note that this may be long to run as it depends on the combination of all</span>
    <span class="c1"># inputs: we need to make sure that the estimated parameters fall within</span>
    <span class="c1"># the predefined value ranges to exclude corner solutions.</span>
    <span class="p">(</span><span class="n">parametersScan</span><span class="p">,</span> <span class="n">scoreScan</span><span class="p">,</span> <span class="n">parametersAmenitiesScan</span><span class="p">,</span> <span class="n">modelAmenityScan</span><span class="p">,</span>
     <span class="n">parametersHousing</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">calscan</span><span class="o">.</span><span class="n">EstimateParametersByScanning</span><span class="p">(</span>
         <span class="n">incomeNetOfCommuting</span><span class="p">,</span> <span class="n">dataRent</span><span class="p">,</span> <span class="n">data_sp</span><span class="p">[</span><span class="s2">&quot;dwelling_size&quot;</span><span class="p">],</span>
         <span class="n">data_income_group</span><span class="p">,</span> <span class="n">data_density</span><span class="p">,</span> <span class="n">selected_density</span><span class="p">,</span>
         <span class="n">housing_types_sp</span><span class="p">[</span><span class="s2">&quot;x_sp&quot;</span><span class="p">],</span> <span class="n">housing_types_sp</span><span class="p">[</span><span class="s2">&quot;y_sp&quot;</span><span class="p">],</span> <span class="n">selectedSP</span><span class="p">,</span>
         <span class="n">amenities_sp</span><span class="p">,</span> <span class="n">variables_regression</span><span class="p">,</span> <span class="n">listRho</span><span class="p">,</span> <span class="n">listBeta</span><span class="p">,</span> <span class="n">listBasicQ</span><span class="p">,</span>
         <span class="n">initUti2</span><span class="p">,</span> <span class="n">listUti3</span><span class="p">,</span> <span class="n">listUti4</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">modelAmenityScan</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>

    <span class="c1"># Now we run the optimization algorithm with identified value of the</span>
    <span class="c1"># parameters: this corresponds to an interior-point algorithm.</span>

    <span class="c1"># Note that this may be long to run depending on the optimization programme</span>

    <span class="c1"># Also note that this may not work: the optimization programme partly</span>
    <span class="c1"># relies on interpolated inputs and may not be smooth enough for scipy&#39;s</span>
    <span class="c1"># algorithm to run until the end. We have included some options to try</span>
    <span class="c1"># other solvers that end up performing worse than the standard one:</span>
    <span class="c1"># this is a complex numerical issue whose potential for model improvement</span>
    <span class="c1"># we see as marginal, compared to parameter scanning. Hence, we leave that</span>
    <span class="c1"># for future work.</span>

    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;param_optim&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

        <span class="n">initBeta</span> <span class="o">=</span> <span class="n">parametersScan</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">initBasicQ</span> <span class="o">=</span> <span class="n">parametersScan</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">initUti3</span> <span class="o">=</span> <span class="n">parametersScan</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">initUti4</span> <span class="o">=</span> <span class="n">parametersScan</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

        <span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">scoreTot</span><span class="p">,</span> <span class="n">parametersAmenities</span><span class="p">,</span> <span class="n">modelAmenity</span><span class="p">,</span>
         <span class="n">parametersHousing</span><span class="p">,</span> <span class="n">selectedSPRent</span>
         <span class="p">)</span> <span class="o">=</span> <span class="n">calopt</span><span class="o">.</span><span class="n">EstimateParametersByOptimization</span><span class="p">(</span>
             <span class="n">incomeNetOfCommuting</span><span class="p">,</span> <span class="n">dataRent</span><span class="p">,</span> <span class="n">data_sp</span><span class="p">[</span><span class="s2">&quot;dwelling_size&quot;</span><span class="p">],</span>
             <span class="n">data_income_group</span><span class="p">,</span> <span class="n">data_density</span><span class="p">,</span> <span class="n">selected_density</span><span class="p">,</span>
             <span class="n">housing_types_sp</span><span class="p">[</span><span class="s2">&quot;x_sp&quot;</span><span class="p">],</span> <span class="n">housing_types_sp</span><span class="p">[</span><span class="s2">&quot;y_sp&quot;</span><span class="p">],</span> <span class="n">selectedSP</span><span class="p">,</span>
             <span class="n">amenities_sp</span><span class="p">,</span> <span class="n">variables_regression</span><span class="p">,</span> <span class="n">listRho</span><span class="p">,</span> <span class="n">initBeta</span><span class="p">,</span> <span class="n">initBasicQ</span><span class="p">,</span>
             <span class="n">initUti2</span><span class="p">,</span> <span class="n">initUti3</span><span class="p">,</span> <span class="n">initUti4</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">modelAmenity</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>

    <span class="c1"># Exporting and saving outputs</span>

    <span class="n">amenities_grid</span> <span class="o">=</span> <span class="n">calam</span><span class="o">.</span><span class="n">import_amenities</span><span class="p">(</span><span class="n">path_data</span><span class="p">,</span> <span class="n">path_precalc_inp</span><span class="p">,</span>
                                            <span class="s1">&#39;grid&#39;</span><span class="p">)</span>
    <span class="n">predictors_grid</span> <span class="o">=</span> <span class="n">amenities_grid</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">variables_regression</span><span class="p">]</span>
    <span class="n">predictors_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">predictors_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
         <span class="n">predictors_grid</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;param_optim&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">cal_amenities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">predictors_grid</span> <span class="o">*</span> <span class="n">parametersAmenities</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">calibratedUtility_beta</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">calibratedUtility_q0</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;param_optim&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cal_amenities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">predictors_grid</span> <span class="o">*</span> <span class="n">parametersAmenitiesScan</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">calibratedUtility_beta</span> <span class="o">=</span> <span class="n">parametersScan</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">calibratedUtility_q0</span> <span class="o">=</span> <span class="n">parametersScan</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path_precalc_inp</span> <span class="o">+</span> <span class="s1">&#39;calibratedUtility_beta&#39;</span><span class="p">,</span>
            <span class="n">calibratedUtility_beta</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path_precalc_inp</span> <span class="o">+</span> <span class="s1">&#39;calibratedUtility_q0&#39;</span><span class="p">,</span> <span class="n">calibratedUtility_q0</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path_precalc_inp</span> <span class="o">+</span> <span class="s1">&#39;calibratedAmenities&#39;</span><span class="p">,</span> <span class="n">cal_amenities</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">calibratedUtility_beta</span><span class="p">,</span> <span class="n">calibratedUtility_q0</span><span class="p">,</span> <span class="n">cal_amenities</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Thomas Monnier.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>